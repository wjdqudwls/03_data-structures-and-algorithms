package com.ohgiraffers.section04.dp;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.StringReader;
import java.util.StringTokenizer;

/* =====================================================
 * 0-1 배낭 문제 (0-1 Knapsack Problem - DP)
 * =====================================================
 *
 * === 문제 설명 ===
 * - n개의 물건과 최대 무게 K인 배낭이 주어짐
 * - 각 물건은 무게(w)와 가치(v)를 가짐
 * - 각 물건을 넣거나(1) 넣지 않거나(0) 선택 → "0-1"
 * - 배낭의 무게 제한 내에서 최대 가치를 얻기
 *
 * === 0-1 Knapsack vs Fractional Knapsack ===
 *
 * 0-1 Knapsack (이 문제):
 * - 물건을 통째로만 넣을 수 있음 (분할 불가)
 * - 예: 금괴는 쪼갤 수 없음
 * - DP로 해결 (Greedy는 최적해 보장 X)
 * - 시간 복잡도: O(n × K)
 *
 * Fractional Knapsack (다른 문제):
 * - 물건을 쪼개서 넣을 수 있음 (분할 가능)
 * - 예: 밀가루는 쪼갤 수 있음
 * - Greedy로 해결 (가치/무게 비율 높은 순)
 * - 시간 복잡도: O(n log n)
 *
 * === 예시 ===
 *
 * 물건 목록:
 * 물건 1: 무게 6, 가치 13
 * 물건 2: 무게 4, 가치 8
 * 물건 3: 무게 3, 가치 6
 * 물건 4: 무게 5, 가치 12
 *
 * 배낭 용량: K = 7
 *
 * 가능한 조합:
 * 1) 물건 2 + 물건 3 = 무게 7, 가치 14 ✓ 최대!
 * 2) 물건 3 + 물건 4 = 무게 8 (초과) X
 * 3) 물건 1 = 무게 6, 가치 13
 * 4) 물건 4 = 무게 5, 가치 12
 *
 * 정답: 14
 *
 * === DP 접근 방법 ===
 * dp[i][j] = 처음 i개 물건을 고려하고, 무게 제한이 j일 때의 최대 가치
 *
 * 점화식:
 * dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i])
 *            (안 담는다)   (담는다)
 *
 * === 점화식 유도 ===
 *
 * i번째 물건을 고려할 때:
 *
 * 경우 1: i번째 물건을 넣지 않는다
 * - 가치 변화 없음
 * - dp[i][j] = dp[i-1][j]
 *
 * 경우 2: i번째 물건을 넣는다 (j >= w[i]일 때만 가능)
 * - i번째 물건 가치 + 남은 공간의 최대 가치
 * - dp[i][j] = v[i] + dp[i-1][j-w[i]]
 *
 * 두 경우 중 큰 값 선택:
 * dp[i][j] = max(dp[i-1][j], v[i] + dp[i-1][j-w[i]])
 *
 * === 동작 과정 시각화 ===
 *
 * 입력:
 * n = 4, K = 7
 * 물건 1: w=6, v=13
 * 물건 2: w=4, v=8
 * 물건 3: w=3, v=6
 * 물건 4: w=5, v=12
 *
 * DP 테이블 작성:
 *
 * dp[i][j] (i=물건번호, j=무게제한):
 *
 *       무게: 0  1  2  3  4  5  6  7
 * 물건0:      0  0  0  0  0  0  0  0
 * 물건1(6,13):0  0  0  0  0  0 13 13
 * 물건2(4,8): 0  0  0  0  8  8 13 13
 * 물건3(3,6): 0  0  0  6  8  8 13 14
 * 물건4(5,12):0  0  0  6  8 12 13 14
 *
 * === 테이블 작성 과정 상세 ===
 *
 * 물건 1 (w=6, v=13):
 * - j < 6: dp[1][j] = dp[0][j] = 0 (물건이 안 들어감)
 * - j=6: dp[1][6] = max(dp[0][6], 13 + dp[0][0]) = max(0, 13) = 13
 * - j=7: dp[1][7] = max(dp[0][7], 13 + dp[0][1]) = max(0, 13) = 13
 *
 * 물건 2 (w=4, v=8):
 * - j < 4: dp[2][j] = dp[1][j]
 * - j=4: dp[2][4] = max(dp[1][4], 8 + dp[1][0]) = max(0, 8) = 8
 * - j=5: dp[2][5] = max(dp[1][5], 8 + dp[1][1]) = max(0, 8) = 8
 * - j=6: dp[2][6] = max(dp[1][6], 8 + dp[1][2]) = max(13, 8) = 13
 * - j=7: dp[2][7] = max(dp[1][7], 8 + dp[1][3]) = max(13, 8) = 13
 *
 * 물건 3 (w=3, v=6):
 * - j=3: dp[3][3] = max(dp[2][3], 6 + dp[2][0]) = max(0, 6) = 6
 * - j=4: dp[3][4] = max(dp[2][4], 6 + dp[2][1]) = max(8, 6) = 8
 * - j=7: dp[3][7] = max(dp[2][7], 6 + dp[2][4]) = max(13, 6+8) = 14 ✓
 *
 * 물건 4 (w=5, v=12):
 * - j=5: dp[4][5] = max(dp[3][5], 12 + dp[3][0]) = max(8, 12) = 12
 * - j=7: dp[4][7] = max(dp[3][7], 12 + dp[3][2]) = max(14, 12) = 14
 *
 * 최종 답: dp[4][7] = 14 (물건 2 + 물건 3)
 *
 * === 역추적 (어떤 물건을 선택했는지) ===
 *
 * dp[4][7] = 14:
 * - dp[4][7] == dp[3][7] → 물건 4 선택 X
 *
 * dp[3][7] = 14:
 * - dp[3][7] > dp[2][7] → 물건 3 선택 ✓
 * - j = 7 - 3 = 4로 이동
 *
 * dp[2][4] = 8:
 * - dp[2][4] > dp[1][4] → 물건 2 선택 ✓
 * - j = 4 - 4 = 0으로 이동 (종료)
 *
 * 선택된 물건: 2, 3
 *
 * === Greedy가 안 되는 이유 ===
 *
 * Greedy (가치/무게 비율 높은 순):
 * 물건 1: 13/6 = 2.17
 * 물건 2: 8/4 = 2.00
 * 물건 3: 6/3 = 2.00
 * 물건 4: 12/5 = 2.40 ← 최고 비율
 *
 * Greedy 선택: 물건 4 (무게 5) → 남은 용량 2
 * → 더 이상 넣을 물건 없음
 * → 총 가치: 12 (최적 아님!)
 *
 * DP 선택: 물건 2 + 물건 3 (무게 7)
 * → 총 가치: 14 (최적!)
 *
 * === 시간 복잡도 ===
 * - 외부 반복: i = 1 ~ n (n개 물건)
 * - 내부 반복: j = 1 ~ K (K개 무게)
 * - 시간 복잡도: O(n × K)
 * - 의사 다항 시간 (Pseudo-polynomial)
 *   → K가 매우 크면 비효율적
 *
 * === 공간 복잡도 ===
 * - dp 배열: O(n × K)
 * - 공간 복잡도: O(n × K)
 *
 * === 공간 최적화 ===
 * 1차원 배열로 최적화 가능:
 * - 이전 행만 참조하므로 1차원으로 충분
 * - 단, 뒤에서부터 갱신해야 함 (덮어쓰기 방지)
 *
 * int[] dp = new int[K+1];
 * for(int i = 1; i <= n; i++) {
 *     for(int j = K; j >= w[i]; j--) {
 *         dp[j] = Math.max(dp[j], v[i] + dp[j-w[i]]);
 *     }
 * }
 * → 공간 복잡도: O(K)
 *
 * === 변형 문제 ===
 * 1. Unbounded Knapsack: 물건을 무한히 넣을 수 있음
 * 2. Bounded Knapsack: 각 물건마다 개수 제한
 * 3. Multiple Knapsack: 여러 개의 배낭
 * 4. 2D Knapsack: 무게와 부피 2가지 제약
 *
 * === 실생활 응용 ===
 * - 자원 할당 문제
 * - 투자 포트폴리오 선택
 * - 화물 적재 최적화
 * - 메모리 할당 문제
 * - 예산 내에서 프로젝트 선택
 *
 * =====================================================
 */
public class G_Knapsack {
    public static int solution(String input) throws IOException {
        BufferedReader br = new BufferedReader(new StringReader(input));
        StringTokenizer st = new StringTokenizer(br.readLine());

        int n = Integer.parseInt(st.nextToken());   // 물건의 개수
        int k = Integer.parseInt(st.nextToken());   // 배낭의 최대 무게

        /* DP 테이블 초기화
         * dp[i][j] = 처음 i개 물건을 고려하고, 무게 제한이 j일 때의 최대 가치
         */
        int[][] dp = new int[n + 1][k + 1];

        /* 각 물건을 순서대로 고려 */
        for(int i = 1; i <= n; i++) {
            st = new StringTokenizer(br.readLine());
            int w = Integer.parseInt(st.nextToken());   // 현재 물건의 무게
            int v = Integer.parseInt(st.nextToken());   // 현재 물건의 가치

            /* 각 물건에 대해 모든 무게를 고려하며 dp 테이블 채우기
             * j = 현재 고려하는 배낭의 무게 제한
             */
            for(int j = 1; j <= k; j++) {
                /* 물건이 가방에 들어갈 수 있는지 확인 */
                if(j < w) {
                    /* 경우 1: 물건이 들어갈 수 없다면 (j < w)
                     * - 이 물건을 넣을 수 없음
                     * - 이전 물건들까지만 고려한 값 그대로 유지
                     * - dp[i][j] = dp[i-1][j]
                     */
                    dp[i][j] = dp[i-1][j];
                } else {
                    /* 경우 2: 물건이 들어갈 수 있다면 (j >= w)
                     * 두 가지 선택지 중 큰 값 선택:
                     *
                     * 선택지 A: 이 물건을 넣지 않는다
                     * - 가치: dp[i-1][j] (이전 최대값 유지)
                     *
                     * 선택지 B: 이 물건을 넣는다
                     * - 현재 물건 가치: v
                     * - 남은 공간(j-w)의 최대 가치: dp[i-1][j-w]
                     * - 가치: v + dp[i-1][j-w]
                     *
                     * dp[i][j] = max(안 넣는다, 넣는다)
                     */
                    dp[i][j] = Math.max(dp[i-1][j], v + dp[i-1][j-w]);
                }
            }
        }

        /* 최종 결과: n개 물건을 모두 고려하고, 무게 k까지 사용했을 때의 최대 가치 */
        return dp[n][k];
    }

}
